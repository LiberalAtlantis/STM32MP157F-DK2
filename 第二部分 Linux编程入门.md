# Linux编程入门

## 1 Shell基本操作

Shell 命令的格式如下：

~~~bash
command -option [argument]
~~~

command : Shell 命令名称。
option : 选项，同一张命令可能有不同的选项，不同的选项其实现的功能不同。
argument:Shell 命令是可以带参数的，也可以不带参数运行。

同样以命令"ls"为例，下面"ls"命令的三种不同格式其结果也不同：

ls
用来打印出当前目录下的所有文件和文件夹

ls -l
打印出当前目录下的所有文件和文件夹，但是此命令会列出所有文件和文件夹里的详细信息，比如文件大小、拥有者、创建日期等。

ls /usr
打印出目录"/usr"下的所有文件和文件夹

Shell命令支持自动补全功能，使用自动补全功能以后我们只需要输入命令的前一部分字母，然后按下TAB键，如果只有一个命令匹配就会自动补全这个命令剩下的字母。如果有多个命令匹配的话系统会发出警报，此时再下一次TAB键就会列出所有匹配的命令。

### 1.1 常用Shell命令

#### 1.1.1 目录信息查看命令 ls

文件浏览命令"ls"，格式如下：

~~~bash
ls [选项] [路径]
~~~

ls 命令主要用于显示指定目录下的内容，列出指定目录下包含的所有文件以及子目录，主要参数有：

-a:显示所有的文件以及子目录，包括以"."开头的隐藏文件。

-l:显示文件的详细信息，比如文件的形态、权限、所有者、大小等信息。

-t:将文件按照创建时间排序列出。

-A:和a一样，但是不列出"."(当前目录)和".."(父目录)。

-R:递归列出所有文件，包括子目录中的文件。

Shell命令里的参数是可以组合在一起用的，比如组合"-al"就是显示所有文件的详细信息，包括以"."开头的隐藏文件。

#### 1.1.2 目录切换命令 cd

在Shell中切换到其它的目录，使用的命令是"cd"，命令格式如下：

~~~bash
cd [路径]
~~~

路径就是我们要进入的目录路径，比如下面所示操作：

cd /
进入到根目录"/"下，Linux系统的根目录为"/"

cd /usr
进入到目录"/usr"

cd ..
进入到上一级目录

cd ~
切换到当前用户目录

#### 1.1.3 当前路径显示命令 pwd

~~~bash
pwd
~~~

#### 1.1.4 系统信息查看命令 uname

查看当前系统信息，可以使用命令"uname"，命令格式如下：

~~~bash
uname [选项]
~~~

可选的选项参数如下：

-r:列出当前系统的具体内核版本号

-s:列出系统内核名称

-o:列出系统信息。

#### 1.1.5 清屏命令 clear

"clear"命令用于清除终端上的所有内容，只留下一行提示符。

#### 1.1.6 切换用户执行身份命令 sudo

Linux是一个允许多用户的操作系统，其中权限最大的就是超级用户root，有时候我们执行一些操作的时候是需要用到root用户身份才能执行，通过sudo命令可以使我们暂时将身份切换到root用户。当使用sudo命令的时候是需要输入密码的，治理要注意输入密码的时候是没有任何提示的。命令格式如下：

~~~bash
sudo [选项] [命令]
~~~

选项主要参数如下：

-h:显示帮助信息。

-l:列出当前用户可执行与不可执行的命令。

-p:改变询问密码的提示符。

#### 1.1.7 添加用户命令 adduser

此命令需要root身份去运行。命令格式如下：

~~~bash
adduser [参数] [用户名]
~~~

常用的参数如下：

-system:添加一个系统用户。

-home DIR:DIR表示用户的主目录路径。

-uid ID:ID表示用户的uid。

-ingroup GRP:表示用户所属的组名。

#### 1.1.8 删除用户命令 deluser

删除用户使用命令"deluser"，命令格式如下：

~~~bash
deluser [参数] [用户名]
~~~

主要参数有：

-system:当用户是一个系统用户的时候才能删除。

-remove-home:删除用户的主目录。

-remove-all-files:删除与用户有关的所有文件

-backup:备份用户信息

同样的，命令"deluser"也要使用"sudo"来以root用户运行。

#### 1.1.9 切换用户命令 su

"sudo"是以root用户身份执行一个命令，并没有更改当前的用户身份，所有需要root身份执行的明星都必须在前面加上"sudo"。
命令"su"可以直接将当前用户切换为root用户。"su"命令格式如下：

~~~bash
su [选项] [用户名]
~~~

常用选项参数如下：

-c-command:执行指定的命令，执行完毕以后恢复原用户身份。
-login:改变用户身份，同时改变工作目录和PATH环境变量。
-m:改变用户身份的时候不改变环境变量。
-h:显示帮助信息。

以切换到root用户为例

~~~bash
sudo su
~~~

先使用"sudo su"切换到root用户，su命令不写明用户名的话默认切换到root用户。
要切换回原来的用户，使用命令"sudo su 用户名"即可。

#### 1.1.10 显示文件内容命令 cat

Linux下有类似记事本的软件，叫做gedit，找到一个文本文件，双击打开，默认使用的就是gedit。

"cat"命令格式如下：

~~~bash
cat [选项] [文件]
~~~

选项主要参数如下：

-n:有1开始对所有输出的行进行编号。

-b:和-n类似，但是不对空白行编号。

-s:当遇到连续两个行以上空白行的话就合并为一个空白行。

#### 1.1.11 显示和配置网络属性命令 ifconfig

Ubuntu默认没有"ifconfig"命令，需要自己手动安装，在终端输入如下命令：

~~~bash
sudo apt-get install net-tools
~~~

"ifconfig"是一个跟网络属性配置和显示密切相关的命令，通过此命令我们可以查看当前网络属性，也可以通过次命令配置网络属性，比如设置网络IP地址等，此命令格式如下：

~~~bash
ifconfig interface options|address
~~~

主要参数如下：

interface:网络接口名称，比如eth0等。

up:开启网络设置。

down:关闭网络设备。

add:IP地址，设置网络IP地址。

netmask add:子网掩码

#### 1.1.12 系统帮助命令 man

"man"命令可以查看其它命令的语法格式、主要功能、主要参数说明等，“man”命令个数如下：

~~~bash
man [命令名]
~~~

比如我们要查看命令"ifconfig"的说明，输入"man ifconfig"即可。

#### 1.1.13 系统重启命令 reboot

~~~bash
reboot
~~~

#### 1.1.14 系统关闭命令 poweroff

~~~bash
poweroff
~~~

#### 1.1.15 软件安装命令 install

命令"install"格式如下：

~~~bash
install [选项]…… [-T] 源文件 目标文件
或：install [选项]…… 源文件…… 目录
或：install [选项]…… -t 目录 源文件……
或：install [选项]…… -d 目录……
~~~

"install"命令是将文件(通常是编译后的文件)赋值到目的位置，在前三种形式中，将源文件复制到目标文件或将多个源文件复制到一个已存在的目录中同时设置其所有权和权限模式。在第四种形式会创建指定的目录。命令"install"通常和"apt-get"组合在一起使用。

## 2 APT下载工具

APT下载工具可以实现软件自动下载、配置、安装二进制或者源码的功能。APT下载工具和"install"命令结合在一起构成了Ubuntu下最常用的下载和安装软件方法。它解决了Linux平台下安装软件的一个缺陷，即软件之间相互依赖。

APT采用的C/S模式，也就是客户端/服务器模式，我们的PC机作为客户端，当需要下载软件的时候就像服务器请求，因此我们需要知道服务器的地址也叫作安装源或者更新源。

“Ubuntu软件”选项卡下面的“下载自”就是APT工具的安装源。

### 2.1 更新本地数据库

如果想查看本地哪些软件可以更新的话可以使用如下命令：

~~~bash
sudo apt-get update
~~~

这个命令会访问源地址，并且获取软件列表并保存在本电脑上。

### 2.2 检查依赖关系

有时候本地某些软件存在依赖关系，所谓依赖关系就是A软件依赖于B软件。通过如下命令可以查看依赖关系，如果存在依赖关系的话APT会提出解决方案：

~~~bash
sudo apt-get check
~~~

### 2.3 软件安装

安装软件，使用如下命令：

~~~bash
sudo apt-get install package-name
~~~

上述命令是由"apt-get"和"install"组合在一起的，"package-name"就是要安装的软件名字，"apt-get"负责下载软件，"install"负责安装软件。

例如，安装Ubuntu下的串口工具软件"minicom"，可以使用如下命令：

~~~bash
sudo apt-get install minicom
~~~

执行上述命令以后就会自动下载和安装"minicom"软件。

安装完成以后，在中断中输入如下命令打开"minicom":

~~~bash
minicom -s
~~~

### 2.4 软件更新

使用如下命令更新软件：

~~~bash
sudo apt-get upgrade package-name
~~~

### 2.5 卸载软件

使用如下命令卸载某个软件：

~~~bash
sudo apt-get remove package-name
~~~

其中，package-name是要卸载的软件，比如卸载"minicom"命令如下：

~~~bash
sudo apt-get remove minicom
~~~

## 3 Ubuntu下文本编辑

### 3.1 gedit编辑器

gedit是一个窗口式的编辑器。

### 3.2 vi/vim编辑器

如果我们需要在终端模式下进行文本编辑或者修改文件就可以使用vi/vim编辑器，Ubuntu自带了vi编辑器。

vim编辑器是vi编辑器的升级版本，vi/vim编辑器都是一种基于指令式的编辑器，不需要鼠标，也没有菜单，仅仅使用键盘来完成所有的编辑工作。

使用如下命令，安装vim编辑器：

~~~bash
sudo apt-get install vim
~~~

安装完成后就可以使用vim编辑器了，vim编辑器有三种工作模式：输入模式、指令模式和底行模式，通过切换不同的模式可以完成不同的功能。

打开终端，输入命令：vim test.txt

~~~bash
vim test.txt
~~~

vim默认以只读模式打开文档，因此我们要切换到输入模式，切换到输入模式的命令如下：

i:在当前光标所在字符前，转换为输入模式。

I:在当前光标所在行的行首，转换为输入模式。

a:在当前光标所在字符后，转换为输入模式。

A:在光标所在行的行尾，转换为输入模式。

o:在当前光标所在行的下方，新建一行，并转换为输入模式。

O:在当前光标所在行的上方，新建一行，并转换为输入模式。

s:删除光标所在字符。

r:替换光标处字符。

如果按下Ctrl+S关闭了当前终端的话，可以按Ctrl+Q来重新打开终端。

保存使用vim打开的文本文档，需要将vim从输入模式切换到指令模式，方式是按下键盘的ESC键。按下ESC键以后，终端左下角“插入”字样就会消失，此时就不能输入任何文本了，如果想再次输入文本，就按下"a"键重新进入输入模式。

指令模式就是输入指令的模式，这些指令是控制文本的指令，我们将这些指令进行分类，如下：

#### 3.2.1 移动光标指令

h(或左方向键)：光标左移一个字符。

l(或右方向键)：光标右移一个字符。

j(或下方向键)：光标下移一行。

k(或上方向键)：光标上移一行。

nG：光标移动到第n行首。

n+：光标下移n行。

n-：光标上移n行。

#### 3.2.2 屏幕翻滚指令

Ctrl+f：屏幕向下翻一夜，相当于下一页。

Ctrl+b：屏幕向上翻一页，相当于上一页。

#### 3.2.3 复制、删除和粘贴指令

cc：删除整行，并且修改整行内容。

dd：删除该行，不提供修改功能。

ndd：删除当前行向下n行。

x：删除光标所在的字符。

X：删除光标前面的一个字符。

nyy：复制当前行及其下面n行。

p：粘贴最近复制的内容。

#### 3.2.4 文本保存指令

保存文档的命令在底行模式中，进入底行模式的方式是先进入指令模式，在指令模式下输入":"进入底行模式。

当进入底行模式以后会在终端的左下角出现符号":"，可以在":"后面输入命令，常用命令如下：

x：保存当前文档并且退出。

q：退出。

w：保存文档。

q!：退出vi/vim，不保存文档。

wq：退出并保存文档。

除了在指令模式下输入":"的方法，还可以在指令模式下输入"/"进入底行模式。

在"/"底行模式下可以在文本中搜索指定的内容。

## 4 Linux文件系统

操作系统的基本功能之一就是文件管理，而文件管理是由文件系统来完成的。Linux支持多种文件系统。本节简介Linux下的文件系统、文件系统类型、文件系统结构和文件系统相关Shell命令。

### 4.1 Linux文件系统简介

操作系统处理硬盘上的各种二进制数据，需要一个翻译器将这些二进制数据还原为人类能看懂的文件形式，这个工作就是由文件系统来完成的，文件系统的目的就是实现数据的查询和存储，Linux有多种文件系统，不同的文件系统支持不同的体系。文件系统室管理数据的，可以存储数据的物理设备有硬盘、U盘、SD卡、NAND Flash、NOR Flash、网络存储设备等。不同的春出设备器物理结构不同，不同的物理结构需要不同的文件系统去管理，比如管理NAND Flash使用YAFFS文件系统，管理硬盘、SD卡使用ext文件系统等等。

Linux和Windows一样也支持磁盘分割，Linux下常用的磁盘分割工具为：fdisk。我们移植Linux的时候需要将SD卡分为三个分区来存储不同的东西。

Windows下格式化磁盘的时候选择文件系统，一般有FAT、NTFS和exFAT这些文件系统。同样，在Linux下我们使用fdisk创建好分区以后也是要先在创建好的分区上面创建文件系统，也就是格式化。在Linux下创建一个分区并且格式化好以后我们要将其“挂载”到一个目录下才能访问这个分区。Windows的文件系统挂载过程是其内部完成的，用户是看不到的，Linux下我们使用mount命令来挂载磁盘。挂载磁盘的时候是需要确定挂载点的，也就是你的这个磁盘要挂载到哪个目录下。

### 4.2 Linux文件系统类型

Linux下的文件系统主要有ext2、ext3、ext4等。Linux还支持其他的UNIX文件系统，比如XFS、JFS、UFS等，也支持Windows的FAT文件系统和网络文件系统NFS等。

ext2文件系统：

ext2是Linux早期的文件系统，但是随着技术的发展ext2文件系统已经不推荐使用了，ext2是一个非日志文件系统,大多数的Linux发行版都不支持ext2文件系统了。

ext3文件系统：

ext3是在ext2的基础上发展起来的文件系统，完全兼容ext2文件系统，ext3是一个日志文件系统，ext3支持大文件，ext3文件系统的特点有如下：

高可靠性：使用ext3文件系统的话，即使系统非正常关机、发生死机等情况，恢复ext3文件系统也只需要数十秒。

数据完整性：ext3提高了文件系统的完整性，避免意外死机或者关机对文件系统的伤害。

文件系统速度：ext3的日志功能对磁盘驱动器读写头进行了优化，文件系统速度相对与ext2来说没有降低。

数据转换：从ext2转换到ext3非常容易，只需要两条指令就可以完成转换。用户不需要花时间去备份、恢复、格式化分区等，用ext3文件系统提供的工具tune2fs即可轻松的将ext2文件系统转换为ext3日志文件系统。ext3文件系统不需要经过任何修改，可以直接挂载成ext2文件系统。

ext4文件系统：

ext4文件系统是在ext3上发展起来的，ext4相比与ext3提供了更佳的性能和可靠性，并且功能更丰富，ext4向下兼容ext3和ext2，因此可以将ext2和ext3挂载为ext4。

在Ubuntu终端中输入如下命令来查询当前磁盘挂载的啥文件系统：

~~~bash
df  -T  –h
~~~

### 4.3 Linux文件系统结构

在Linux下因为没有C、D盘之说，只有一个根目录，没有C盘根目录、D盘根目录之类的。在Linux下的根目录就是“/”，Linux根目录就是用“/”来表示的，

Ubuntu会给每个用户创建一个根目录，这个所谓的用户根目录其实就是“/”下的一个文件夹，以“username”这个用户为例，其用户根目录就是：“/home/username”。只要你创建了一个用户，系统就会在“/home”这个目录下创建一个以这个用户名命名的文件夹，这个文件夹就是这个用户的根目录。

用户可以对自己的用户根目录下的文件进行随意的读写操作，但是如果要修改根目录“/”下的文件就会提示没有权限。打开终端以后默认进入的是当前用户根目录。

我们来看一下根目录“/”下都有哪些文件，在终端中输入如下命令：

~~~bash
cd /    //进入到根目录“/”
ls      //查看根目录“/”下的文件以及文件夹
~~~

当我们进入到根目录“/”里面以后，终端提示符“$”前面的符号“~”变成了“/”，这是因为当我们在终端中切换了目录以后“$”前面就会显示切换以后的目录路径。

根目录“/”中的一些重要的文件夹：

/bin：存储一些二进制可执行命令文件，/usr/bin也存放了一些基于用户的命令文件。

/sbin：存储了很多系统命令，/usr/sbin也存储了许多系统命令。

/root：超级用户root的根目录文件。

/home：普通用户默认目录，在该目录下，每个用户都有一个以本用户名命名的文件夹。

/boot：存放Ubuntu系统内核和系统启动文件。

/mnt：通常包括系统引导后被挂载的文件系统的挂载点。

/dev：存放设备文件，我们后面学习Linux驱动主要是跟这个文件夹打交道的。

/etc：保存系统管理所需的配置文件和目录。

/lib：保存系统程序运行所需的库文件，/usr/lib下存放了一些用于普通用户的库文件。

/lost+found：一般为空，当系统非正常关机以后，此文件夹会保存一些零散文件。

/var：存储一些不断变化的文件，比如日志文件

/usr：包括与系统用户直接有关的文件和目录，比如应用程序和所需的库文件。

/media：存放Ubuntu系统自动挂载的设备文件。

/proc：虚拟目录，不实际存储在磁盘上，通常用来保存系统信息和进程信息。

/tmp：存储系统和用户的临时文件，该文件夹对所有的用户都提供读写权限。

/opt：可选文件和程序的存放目录。

/sys：系统设备和文件层次结构，并向用户程序提供详细的内核数据信息。

### 4.4 文件操作命令

#### 4.4.1 创建新文件命令—touch

touch不仅仅可以用用来创建文本文档，其它类型的文档也可以创建，命令格式如下：

~~~bash
touch [参数] [文件名]
~~~

使用touch创建文件的时候，如果[文件名]的文件不存在，那就直接创建一个以[文件名]命名的文件，如果[文件名]文件存在的话就仅仅修改一下此文件的最后修改日期，常用的命令参数如下：

-a：只更改存取时间。

-c：不建立任何文件。

-d<日期>：使用指定的日期，而并非现在日期。

-t<时间>：使用指定的时间，而并非现在时间。

#### 4.4.2 文件夹创建命令—mkdir

创建文件夹使用命令“mkdir”，命令格式如下：

~~~bash
mkdir [参数] [文件夹名目录名]
~~~

主要参数如下：

-p：如所要创建的目录其上层目录目前还未创建，那么会一起创建上层目录。

#### 4.4.3 文件及目录删除命令—rm

要删除一个文件或者文件夹可以使用命令“rm”，此命令可以完成删除一个文件或者多个文件及文件夹，它可以实现递归删除。对于链接文件，只删除链接，原文件保持不变，所谓的链接文件，其实就是Windows下的快捷方式文件，此命令格式如下：

~~~bash
rm [参数] [目的文件或文件夹目录名]
~~~

命令主要参数如下：

-d：直接把要删除的目录的硬连接数据删成0，删除该目录。

-f：强制删除文件和文件夹(目录)。

-i：删除文件或者文件夹(目录)之前先询问用户。

-r：递归删除，指定文件夹(目录)下的所有文件和子文件夹全部删除掉。

-v：显示删除过程。

#### 4.4.4 文件夹(目录)删除命令—rmdir

使用命令“rm”删除文件夹，要加上参数“-rf”，其实Linux提供了直接删除文件夹(目录)的命令—rmdir，它可以不加任何参数的删除掉指定的文件夹(目录)，命令格式如下：

~~~bash
rmdir [参数] [文件夹(目录)]
~~~

命令主要参数如下：

-p：删除指定的文件夹(目录)以后，若上层文件夹(目录)为空文件夹(目录)的话就将其一起删除。

#### 4.4.5 文件复制命令—cp

Linux终端下的复制命令为“cp”，命令描述如下：

~~~bash
cp [参数] [源地址] [目的地址]
~~~

主要参数描述如下：

-a：此参数和同时指定“-dpR”参数相同。

-d：在复制有符号连接的文件时，保留原始的连接。

-f：强行复制文件，不管要复制的文件是否已经存在于目标目录。

-I：覆盖现有文件之前询问用户。

-p：保留源文件或者目录的属性。

-r或-R：递归处理，将指定目录下的文件及子目录一并处理。

#### 4.4.6 文件移动命令—mv

有时候我们需要将一个文件或者文件夹移动到另外一个地方去，或者给一个文件或者文件夹进行重命名，这个时候我们就可以使用命令“mv”了，此命令格式如下：

~~~bash
mv [参数] [源地址] [目的地址]
~~~

主要参数描述如下：

-b：如果要覆盖文件的话覆盖前先进行备份。

-f：若目标文件或目录与现在的文件重复，直接覆盖目的文件或目录。

-I：在覆盖之前询问用户。

### 4.5 文件压缩和解压缩

#### 4.5.1 图形化压缩和解压缩

图形化压缩和解压缩和Windows下基本一样，在要压缩或者解压的文件上点击鼠标右键，然后选择要进行的操作，我们先讲解一下如何进行文件的压缩。首先找到要压缩的文件，然后在要压缩的文件上点击鼠标右键，选择“压缩”选项。

对压缩的test.zip进行解压缩，鼠标放到test.zip上然后点击鼠标右键，选择“提取到此处”。

#### 4.5.2 命令行进行文件的压缩和解压缩

命令行下进行压缩和解压缩常用的命令有三个：zip、unzip和tar，我们依次来学习：

##### 4.5.2.1 命令zip

zip命令是针对.zip文件的，用于将一个或者多个文件压缩成一个.zip结尾的文件，命令格式如下：

~~~bash
zip [参数] [压缩文件名.zip] [被压缩的文件]
~~~

主要参数函数如下：

-b<工作目录>指定暂时存放文件的目录。

-d：从zip 文件中删除一个文件。

-F：尝试修复已经损毁的压缩文件。

-g：将文件压缩入现有的压缩文件中，不需要新建压缩文件。

-h：帮助。

-j：只保存文件的名，不保存目录。

-m ：压缩完成以后删除源文件。

-n<字尾符号>：不压缩特定扩展名的文件。

-q：不显示压缩命令执行过程。

-r ：递归压缩，将指定目录下的所有文件和子目录一起压缩。

-v：显示指令执行过程。

-num：压缩率，为1~9的数值。

使用zip命令进行test2文件夹的压缩，我们使用的命令如下：

~~~bash
zip -rv test2.zip test2
~~~

上述命令中，-rv表示递归压缩并且显示压缩命令执行过程。

##### 4.5.2.2 命令unzip

unzip命令用于对.zip格式的压缩包进行解压，命令格式如下：

~~~bash
unzip [参数] [压缩文件名.zip]
~~~

主要参数如下：

-l：显示压缩文件内所包含的文件。

-t ：检查压缩文件是否损坏，但不解压。

-v：显示命令显示的执行过程。

-Z ：只显示压缩文件的注解。

-C：压缩文件中的文件名称区分大小写。

-j：不处理压缩文件中的原有目录路径。

-L：将压缩文件中的全部文件名改为小写。

-n：解压缩时不要覆盖原有文件。

-P<密码>：解压密码。

-q：静默执行，不显示任何信息。

-x<文件列表>：指定不要处理.zip中的哪些文件。

-d<目录>：把压缩文件解到指定目录下。

对上面压缩的test2.zip文件使用unzip命令进行解压缩，命令如下：

~~~bash
unzip test2.zip
~~~

##### 4.5.2.2 命令tar

zip和unzip两个命令只适用于.zip格式的压缩和解压，其它压缩格式用不了，比如Linux下最常用的.bz2和.gz这两种压缩格式。其它格式的压缩和解压使用命令tar，tar将压缩和解压缩集合在一起，使用不同的参数即可，命令格式如下：

~~~bash
tar [参数] [压缩文件名] [被压缩文件名]
~~~

常用参数如下：

-c：创建新的压缩文件。

-C<目的目录>：切换到指定的目录。

-f<备份文件>：指定压缩文件。

-j：用tar生成压缩文件，然后用bzip2进行压缩。

-k：解开备份文件时，不覆盖已有的文件。

-m：还原文件时，不变更文件的更改时间。

-r：新增文件到已存在的备份文件的结尾部分。

-t：列出备份文件内容。

-v：显示指令执行过程。

-w：遭遇问题时先询问用户。

-x：从备份文件中释放文件，也就是解压缩文件。

-z：用tar生成压缩文件，用gzip压缩。

-Z：用tar生成压缩文件，用compress压缩。

###### 4.5.2.2.1 压缩

使用如下两个命令将test1文件夹压缩为.bz2和.gz这两个格式：

~~~bash
tar -vcjf test1.tar.bz2 test1
tar -vczf test1.tar.gz test1
~~~

在上面两行命令中，-vcjf表示创建bz2格式的压缩文件，-vczf表示创建.gz格式的压缩文件。

###### 4.5.2.2.2 解压缩

使用如下所示两行命令完成.bz2和.gz格式文件的解压缩：

~~~bash
tar -vxjf test1.tar.bz2
tar -vxzf test2.tar.gz
~~~

上述两行命令中，-vxjf用来完成.bz2格式压缩文件的解压，-vxzf用来完成.gz格式压缩文件的解压。

### 4.6 文件查询和搜索

本节讲解两个最常用的文件查询和搜索命令：find和grep。

#### 4.6.1 命令find

find命令用于在目录结构中查找文件，其命令格式如下：

find [路径] [参数] [关键字]

路径是要查找的目录路径，如果不写表示在当前目录下查找，关键字是文件名的一部分，主要参数如下：

-name "filename"：按照文件名称查找，查找与filename匹配的文件，可使用通配符。

-depth：从指定目录下的最深层的子目录开始查找。

-gid<群组识别码>：查找符合指定的群组识别码的文件或目录。

-group<群组名称>：查找符合指定的群组名称的文件或目录。

-size<文件大小>：查找符合指定文件大小的文件。

-type<文件类型>：查找符合指定文件类型的文件。

-user<拥有者名称>：查找符合指定的拥有者名称的文件或目录。

#### 4.6.2 命令grep

find命令用于在目录中搜索文件，grep命令用于查找包含指定关键字的文件，如果发现某个文件的内容包含所指定的关键字，grep命令就会把包含指定关键字的这一行标记出来，grep命令格式如下：

~~~bash
grep [参数] 关键字 文件列表
~~~

grep命令一次只能查一个关键字，主要参数如下：

-b：在显示符合关键字的那一列前，标记处该列第1个字符的位编号。

-c：计算符合关键字的列数。

-d<进行动作>：当指定要查找的是目录而非文件时，必须使用此参数！否则grep指令将回报信息并停止搜索。

-i：忽略字符大小写。

-v：反转查找，只显示不匹配的行。

-r：在指定目录中递归查找。

比如我们在目录/usr下递归查找包含字符“Ubuntu”的文件，操作如下：

~~~bash
grep -ir "Ubuntu" /usr
~~~

### 4.7 文件类型

这里的文件类型不是说这个文件是音乐文件还是文本文件，在用户根目录下使用命令“ls -l”来查看用户根目录下所有文件的详细信息。

每个文件的详细信息占一行，每行最前面都是一个符号就标记了当前文件类型，比如test1的第一个字符是“d”，test1.tar.bz2文件第一个字符是“-”。这些字符表示的文件类型如下：

-：普通文件，一些应用程序创建的，比如文档、图片、音乐等等。

d：目录文件。

c：字符设备文件，Linux驱动里面的字符设备驱动，比如串口设备，音频设备等。

b：块设备文件，存储设备驱动，比如硬盘，U盘等。

l：符号连接文件，相当于Windwos下的快捷方式。

s：套接字文件。

p：管道文件，主要指FIFO文件。

学习Linux驱动开发的时候基本是在和字符设备文件和块设备文件打交道。

## 5 Linux用户权限管理

### 5.1 Ubuntu用户系统

Ubuntu是一个多用户系统，我们可以给不同的使用者创建不同的用户账号，每个用户使用各自的账号登陆，使用用户账号的目的一是方便系统管理员管理，控制不同用户对系统的访问权限，另一方面是为用户提供安全性保护。

在安装Ubuntu系统时被要求创建一个账户，当创建好账号以后，系统会在目录/home下以该用户名创建一个文件夹，所有与该用户有关的文件都会被存储在这个文件文件夹中。同样的，创建其它用户账号的时候也会在目录/home下生成一个文件夹来存储该用户的文件。

装系统的时候创建的用户其权限比后面创建的用户大一点，但是没有root用户权限大，Ubuntu下用户类型分为以下3类：

●初次创建的用户，此用户可以完成比普通用户更多的功能。

●root用户，系统管理员，系统中的玉皇大帝，拥有至高无上的权利。

●普通用户，安装完操作系统以后被创建的用户。

以上三种用户，每个用户都有一个ID号，称为UID，操作系统通过UID来识别是哪个用户，用户相关信息可以在文件/etc/passwd中查看到

~~~bash
cat /etc/passwd
~~~

从配置文件passwd中可以看到，每个用户名后面都有两个数字，比如用户“username”后面“1000:1000”，第一个数字是用户的ID，另一个是用户的GID，也就是用户组ID。Ubuntu里面每个用户都属于一个用户组里面，用户组就是一组有相同属性的用户集合。

### 5.2 权限管理

Ubuntu下会常跟用户权限打交道，权限就是用户对于系统资源的使用限制情况，root用户拥有最大的权限，装系统的时候创建的用户拥有root用户的部分权限，其它普通用户的权限最低。

对于一个文件通常有三种权限：读(r)、写(w)和执行(x)，使用命令“ls-l”可以查看某个目录下所有文件的权限信息。

~~~bash
ls -l
~~~

以文件test.c为例讲解，文件test.c文件信息如下：

~~~bash
-rw-r--r--1 username username        0 10月28 12:05 test.c
~~~

其中“-rw-rw-r--”表示文件权限与用户和用户组之间的关系，第一位表示文件类型。剩下的9位以3位为一组，分别表示文件拥有者的权限，文件拥有者所在用户组的权限以及其它用户权限。后面的“usernameusername”分别代表文件拥有者(用户)和该用户所在的用户组，因此文件test.c的权限情况如下：

（1）文件test.c的拥有者是用户username，其对文件test.c的权限是“rw-”，也就是对该文件拥有读和写两种权限。

（2）用户username所在的用户组也叫做username，其组内用户对于文件test.c的权限是“rw-”，也是拥有读和写这两种权限。

（3）其它用户对于文件test.c的权限是“r--”，也就是只读权限。

对于文件，可读权限表示可以打开查看文件内容，可写权限表示可以对文件进行修改，可执行权限就是可以运行此文件(如果是软件的话)。对于文件夹，拥有可读权限才可以使用命令ls查看文件夹中的内容，拥有可执行权限才能进入到文件夹内部。

如果某个用户对某个文件不具有相应的权限的话就不能进行相应的操作，比如根目录“/”下的文件只有root用户才有权限进行修改，如果以普通用户去修改的话就会提示没有权限。

以用户“username”在根目录“/”创建文件mytest，结果提示我无法创建“mytest”，因为权限不够，因为只有root用户才能在根目录“/”下创建文件。可以使用命令“sudo”命令暂时切换到root用户，这样就可以在根目录“/”下创建文件mytest了。使用命令“sudo”以后就可以在根目录“/”创建文件mytest，在进行其它的操作的时候，遇到提示权限不够的时候都可以使用sudo命令暂时以root用户身份去执行。

文件的权限有三种：读(r)、写(w)和执行(x)，除了用r、w和x表示以外，我们也可以使用二进制数表示，三种权限就可以使用3位二进制数来表示，一种权限对应一个二进制位，如果该位为1就表示具备此权限，如果该位为0就表示没不具备此权限。

|字母|二进制|八进制|
|:----:|:----:|:----:|
|r|100|4|
|w|010|2|
|x|001|1|

如果做过单片机开发的话，就会发现和单片机里面的寄存器位一样，将三种权限r、w和x进行不同的组合，即可得到不同的二进制数和八进制数，3位权限可以组出8种不同的权限组合.

|权限|二进制数|八进制数字|
|:----:|:----:|:----:|
|---|000|0|
|--x|001|1|
|-w-|010|2|
|-wx|011|3|
|r--|100|4|
|r-x|101|5|
|rw-|110|6|
|rwx|111|7|

权限所对应的八进制数字就是每个权限对应的位相加，比如权限rwx就是4+2+1=7。前面的文件test.c其权限为“rw-rw-r--”，因此其十进制表示就是：664。

|字母|意义|
|:----:|:----:|
|r|可读权限|
|w|可写权限|
|x|可执行权限|
|a|所有用户|
|u|归属用户|
|g|归属组|
|o|其它用户|
|=|具备权限|
|+|添加某权限|
|-|去除某权限|

对于文件test.c，我们想要修改其归属用户(username)对其拥有可执行权限，那么就可以使用：u+x。如果希望设置归属用户及其所在的用户组都对其拥有可执行权限就可以使用：gu+x。

### 5.3 权限管理命令

可以使用Shell来操作文件的权限管理，主要用到“chmod”和“chown”这两个命令，我们一个一个来看。

#### 5.3.1 权限修改命令 chmod

命令“chmod”用于修改文件或者文件夹的权限，权限可以使用前面讲的数字表示也可以使用字母表示，命令格式如下：

~~~bash
chmod [参数] [文件名/目录名]
~~~

主要参数如下：

-c：效果类似“-v”参数，但仅回显更改的部分。

-f：不显示错误信息。

-R：递归处理，指定目录下的所有文件及其子文件目录一起处理。

-v：显示指令的执行过程。

例：

1、如何使用命令“chmod”修改一个文件的权限，在用户根目录下创建一个文件test，然后查看其默认权限，

~~~bash
touch test  //创建test文件
ls -l       //查看文件详情
~~~

我们创建了一个文件：test，这个文件的默认权限为“rw-rw-r--”，我们将其权限改为“rwxrw-rw”，对应数字就是766，操作如下：

~~~bash
ls -l test  //查看文件test权限
chmod 766 test  //修改文件test的权限为766
ls -l test  //查看文件test权限
~~~

我们修改文件test的权限为766，修改完成以后的test文件权限为“rwxrw-rw-”，和我们设置的一样，说明权限修改成功。

2、使用字母来修改权限

~~~bash
touch a.c   //创建a.c文件
ls -l a.c  //查看文件权限
chmod u+x a.c  //为文件添加可执行权限
ls -l a.c  //查看文件权限
~~~

3、修改文件夹的权限

~~~bash
ls -l test/
~~~

test文件夹下的文件a.c、b.c和c.c的权限均为“rw-rw-r--”，我们将test文件夹下的所有文件权限都改为“rwxrwxrwx”，也就是数字777。

~~~bash
chmod -R 777 tset/   //递归修改文件权限
ls -l test/          //查看修改权限以后的文件
~~~

#### 5.3.2 文件归属者修改命令 chown

命令chown用来修改某个文件或者目录的归属者用户或者用户组，命令格式如下：

~~~bash
chown [参数] [用户名.<组名>] [文件名/目录]
~~~

其中[用户名.<组名>]表示要将文件或者目录改为哪一个用户或者用户组，用户名和组名用“.”隔开，其中用户名和组名中的任何一个都可以省略，命令主要参数如下：

-c：效果同-v类似，但仅回报更改的部分。

-f：不显示错误信息。

-h：只对符号连接的文件做修改，不改动其它任何相关的文件。

-R：递归处理，将指定的目录下的所有文件和子目录一起处理。

-v：显示处理过程。

在用户根目录下创建一个test文件，查看其文件夹所属用户和用户组。

~~~bash
touch test
ls -l test
~~~

可以看出，文件test的归属用户，所属的用户组，将文件test归属用户改为root用户，所属的用户组也改为root

~~~bash
ls -l test  //显示文件test的归属用户和归属组
sudo chown root.root test   //修改文件test的归属用户和归属组
ls -l test  //查看修改以后的文件test归属用户和归属组
~~~

## 6 Linux磁盘管理

### 6.1 Linux磁盘管理基本概念

Linux的磁盘管理体系和Windows有很大的区别，在Windows下经常会遇到“分区”这个概念，在Linux中一般不叫“分区”而叫“挂载点”。“挂载点”就是将一个硬盘的一部分做成文件夹的形式，这个文件夹的名字就是“挂载点”，不管在哪个发行版的Linux中，用户是绝对看到不到C盘、D盘这样的概念的，只能看到以文件夹形式存在的“挂载点”。

文件/etc/fstab详细的记录了Ubuntu中硬盘分区的情况。

~~~bash
cat /etc/fstab
~~~

打印信息中有一行“/ was on /dev/sda1 during installation”，意思是根目录“/”是在/dev/sda1上的，其中“/”是挂载点，“/dev/sda1”就是我们装Ubuntu系统的硬盘。

可以通过如下命令查看当前系统中的磁盘：

~~~bash
ls  /dev/sd*
~~~

上述命令就是打印出所有以/dev/sd开头的设备文件。sd表示是SATA硬盘或者其它外部设备，最后面的数字表示该硬盘上的第n个分区，比如/dev/sda1就表示磁盘sda上的第一个分区。如果打印信息中的文件都是以/dev/sda开头的，说明当前只有一个硬盘。如果再插上U盘、SD卡啥的就可能会出现/dev/sdb，/dev/sdc等等。如果插入的U盘有两个分区那么可能就会出现/dev/sdb1、dev/sdb2这样的设备文件。

### 6.2 磁盘管理命令

跟磁盘操作有关的命令如下：

#### 6.2.1 磁盘分区命令fdisk

如果要对某个磁盘进行分区，可以使用命令fdisk，命令格如下：

~~~bash
fdisk   [参数]
~~~

主要参数如下：

-b<分区大小>：指定每个分区的大小。

-l：列出指定设备的分区表。

-s<分区编号>：将指定的分区大小输出到标准的输出上，单位为块。

-u：搭配“-l”参数，会用分区数目取代柱面数目，来表示每个分区的起始地址。

比如我要对U盘进行分区，可以使用如下命令：

~~~bash
sudo fdisk /dev/sdb
~~~

提示我们输入“m”可以查看帮助，因为fdisk还有一些字命令，通过输入“m”可以查看都有哪些子命令。常用的命令如下：

p：显示现有的分区

n：建立新分区

t：更改分区类型

d：删除现有的分区

a：更改分区启动标志

w：对分区的更改写入到硬盘或者存储器中。

q：不保存退出。

千万不要对自己装Ubuntu系统进行分区！！！

#### 6.2.2 格式化命令mkfs

使用命令fdisk创建好一个分区以后，我们需要对其格式化，也就是在这个分区上创建一个文件系统，Linux下的格式化命令为mkfs，命令格式如下：

~~~bash
mkfs [参数] [-t 文件系统类型] [分区名称]
~~~

主要参数如下：

fs：指定建立文件系统时的参数。

-V：显示版本信息和简要的使用方法。

-v：显示版本信息和详细的使用方法。

比如我们要格式化U盘的分区/dev/sdb1为FAT格式，那么就可以使用如下命令：

~~~bash
mkfs –t vfat /dev/sdb1
~~~

#### 6.2.3 挂载分区命令mount

使用硬盘或者U盘创建好分区并且格式化以后，那么如何访问磁盘呢？比如我的U盘就一个分区，为/dev/sdb1，如果直接打开文件/dev/sdb1会发现根本就不是我们要的结果。我们需要将/dev/sdb1这个分区挂载到一个文件夹中，然后通过这个文件访问U盘，磁盘挂载命令为mount，命令格式如下：

~~~bash
mount [参数] -t [类型] [设备名称] [目的文件夹]
~~~

命令主要参数有：

-V：显示程序版本。

-h：显示辅助信息。

-v：显示执行过程详细信息。

-o ro：只读模式挂载。

-o rw：读写模式挂载。

-s-r：等于-oro。

-w：等于-orw。

挂载点是一个文件夹，因此在挂载之前先要创建一个文件夹，一般我们把挂载点放到“/mnt”目录下，在“/mnt”下创建一个tmp文件夹，然后将U盘的/dev/sdb1分区挂载到/mnt/tmp文件夹里面。

~~~bash
ls /mnt //查看/mnt目录下的所有文件
sudo mkdir /mnt/tmp //创建文件夹里/mnt/tmp
ls /mnt
sudo mount -t vfat /dev/sdb1 /mnt/tmp   //挂在U盘到/mnt/tmp中
ls /mnt/tmp
~~~

#### 6.2.4 卸载命令umount

当不在需要访问已经挂载的U盘，可以通过umount将其从卸载点卸除，命令格式如下：

~~~bash
umount [参数] -t [文件系统类型] [设备名称]
~~~

-a：卸载/etc/mtab中的所有文件系统。

-h：显示帮助。

-n：卸载时不要将信息存入到/etc/mtab文件中。

-r：如果无法成功卸载，则尝试以只读的方式重新挂载。

-t<文件系统类型>：仅卸载选项中指定的文件系统。

-v：显示执行过程。

上面我们将U盘挂载到了文件夹/mnt/tmp里面，这里我们使用命令umount将其卸载掉

~~~bash
ls /mnt/tmp
sudo umount -t vfat /dev/sdb1
ls /mnt/tmp
~~~

## 7 Linux C编程入门

Ubuntu下有一些可以进行编程的工具，但是大多都只是编辑器，也就是只能进行代码编辑，如果要编译的话就需要用到GCC编译器，使用GCC编译器肯定就要接触到Makefile。本章讲解如何在Ubuntu下进行C语言的编辑和编译、GCC和Makefile的使用和编写。通过本章的学习可以掌握Linux进行C编程的基本方法，为以后的Linux驱动学习做准备。

### 7.1 Hello World

编写代码包括两部分：代码编写和编译，在Windows下可以使用VisualStudio来完成这两部分，可以在VisualStudio下编写代码然后直接点击编译就可以了。但是在Linux下这两部分是分开的，比如我们用VIM进行代码编写，编写完成以后在使用GCC编译器进行编译，其中代码编写工具很多，比如VIM编辑器、Emacs编辑器、VScode编辑器等等，本章使用Ubuntu自带的VIM编辑器。

先来编写一个最简单的“HelloWorld”程序，把Linux下的C编程完整的走一遍。

#### 7.1.1 编写代码

先在用户根目录下创建一个工作文件夹：C_Program，所有的C语言练习都保存到这个工作文件夹下，创建过程如下所示：

~~~bash
mkdir C_Program
~~~

进入刚才创建的C_Program工作文件夹，为了方便管理，后面每个例程都创建一个文件夹来保存所有与本例程有关的文件，创建一个名为“7.1.1”的文件夹来保存我们的“Hello World”程序相关的文件，操作如下所示：

~~~bash
mkdir 7.1.1
~~~

在使用VI编辑器之前我们先做如下设置：

1、设置TAB键为4字节

VI编辑器默认TAB键为8空格，我们改成4空格，用vi打开文件/etc/vim/vimrc，在此文件最后面输入如下代码：

~~~bash
set ts=4
~~~

修改完成以后保存并关闭文件。

2、VIM编辑器显示行号

VIM编辑器默认是不显示行号的，不显示行号不利于代码查看。设置VIM编辑器显示行号，同样是通过在文件/etc/vim/vimrc中添加代码来实现，在文件最后面加入下面一行代码即可：

~~~bash
set nu
~~~

设置好VIM编辑器以后就可以正式开始编写代码了，进入前面创建的“3.1”这个工程文件夹里面，使用vi指令创建一个名为“main.c”的文件，然后在里面输入如下代码：

~~~bash
#include <stdio.h>

int main(int argc,char *argv[])
{
    printf("Hello World!\n");
}
~~~

编写完成以后保存退出vi编辑器，可以使用“cat”命令查看代码是否编写成功

~~~bash
cat main.c
~~~

#### 7.1.2 编译代码

Ubuntu下的C语言编译器是GCC，Ubuntu18默认没有安装GCC工具，因此需要我们手动安装gcc、g++、make等工具，这里我们直接安装build-essential软件包即可，build-essential提供了编译程序所需的所有软件包，输入如下命令：

~~~bash
sudo apt-get install build-essential
~~~

等待安装完成，然后输入如下命令查看GCC编译器的版本号：

~~~bash
gcc-v
~~~

如果输入命令“gcc-v”命令以后，终端输出gcc相关信息，说明电脑已经有GCC编译器了。最后下面的“gcc version”说明本机的GCC编译器版本。注意Target: x86_64-linux-gnu”一行，说明这个GCC编译器是针对X86架构的，因此只能编译在X86架构CPU上运行的程序。如果想要编译在ARM上运行的程序就需要针对ARM的GCC编译器，也就是交叉编译器。

GCC编译器是命令模式的，需要输入命令来使用gcc编译器来编译文件，输入如下命令：

~~~bash
gcc main.c
~~~

上述命令的功能就是使用gcc编译器来编译main.c这个c文件。

当编译完成以后会生成一个a.out文件，这个a.out就是编译生成发的可执行文件，执行此文件看看是否和我们代码的功能一样，执行的方法很简单使用命令：“./+可执行文件”，比如本例程就是命令：./a.out。

~~~bash
./a.out
~~~

执行a.out文件以后终端输出了“Hello World！”，这正是main.c要实现的功能，说明我程序没有错误。a.out这个文件的命名是GCC编译器自动命名的，如果在使用gcc命令的时候加上-o来指定生成的可执行文件名字，比如编译main.c以后生成名为“main”的可执行文件。

~~~bash
gcc main.c -o main
~~~

### 7.2 GCC编译器

#### 7.2.1 gcc命令

使用GCC编译器来编译C文件，使用到的是gcc命令，gcc命令格式如下：

~~~bash
gcc [选项] [文件名字]
~~~

主要选项如下：

-c：只编译不链接为可执行文件，编译器将输入的.c文件编译为.o的目标文件。

-o <输出文件名>：用来指定编译结束以后的输出文件名，如果使用这个选项的话GCC默认编译出来的可执行文件名字为a.out。

-g：添加调试信息，如果要使用调试工具(如GDB)的话就必须加入此选项，此选项指示编译的时候生成调试所需的符号信息。

-O：对程序进行优化编译，如果使用此选项的话整个源代码在编译、链接的的时候都会进行优化，这样产生的可执行文件执行效率就高。

-O2：比-O更幅度更大的优化，生成的可执行效率更高，但是整个编译过程会很慢。

#### 7.2.2 编译错误警告

在文件夹中创建一个main.c文件，在文件里面输入如下代码：

~~~bash
#include <stdio.h>

int main(int argc,char *argv[])
{
    inta,b;
    
    a=3;
    b=4
    printf("a+b=\n",a+b);
}
~~~

在上述代码中有两处错误：第一处是第8行，“b=4”少写了个一个“；”号。第二处是第9行，应该是printf(“a+b=%d\n”,a+b);

我们编译一下上述代码，看看GCC编译器是否能够检查出错误。

可以看出有一个error，提示在main.c文件的第9行有错误，错误类型是在printf之前没有“；”号，这就是第一处错误，我们在“b= 4”后面加上分号，然后接着编译，结果又提示有一个错误。提示我们说文件main.c的第9行：printf(“a+b=\n”, a + b)有warning，错误是因为太多参数了，我们将其改为：printf(“a+b=%d\n”, a + b);修改完成以后接着重新编译一下。

### 7.3 编译流程

GCC编译器的编译流程是：预处理、编译、汇编和链接。

预处理就是展开所有的头文件、替换程序中的宏、解析条件编译并添加到文件中。

编译是将经过预编译处理的代码编译成汇编代码，也就是我们常说的程序编译。

汇编就是将汇编语言文件编译成二进制目标文件。

链接就是将汇编出来的多个二进制目标文件链接在一起，形成最终的可执行文件，链接的时候还会涉及到静态库和动态库等问题。

## 8 Makefile基础

### 8.1 Makefile

使用GCC编译器在Linux进行C语言编译，通过在终端执行gcc命令来完成C文件的编译，如果我们的工程只有一两个C文件，需要输入的命令不多；当文件有几十、上百甚至上万个的时候用，终端输入GCC命令的方法显然是不现实的。我们需要编写一个文件，这个文件能够描述编译哪些源码文件、如何编译，每次需要编译工程的时只需要使用这个文件。为此提出了一个解决大工程编译的工具：make，描述哪些文件需要编译、哪些需要重新编译的文件就叫做Makefile，Makefile就跟脚本文件一样，Makefile里面还可以执行系统命令。使用的时候只需要一个make命令即可完成整个工程的自动编译，极大的提高了软件开发的效率。

如果想详细的研究Makefile，推荐大家阅读《跟我一起写Makefile》这份文档。

### 8.2 Makefile的引入

完成这样一个小工程，通过键盘输入两个整形数字，然后计算他们的和并将结果显示在屏幕上，在这个工程中我们有main.c、input.c和calcu.c这三个C文件和input.h、calcu.h这两个头文件。其中main.c是主体，input.c负责接收从键盘输入的数值，calcu.h进行任意两个数相加。

其中main.c文件内容如下：

~~~bash
#include <stdio.h>
#include "input.h"
#include"calcu.h"

int main(int argc,char *argv[])
{
    inta,b,num;
    
    input_int(&a,&b);
    num=calcu(a,b);
    printf("%d + %d = %d\r\n",a,b,num);
}
~~~

input.c文件内容如下：

~~~bash
#include <stdio.h>
#include "input.h"

void input_int(int*a,int*b)
{
    printf("input two num:");
    scanf("%d %d",a,b);
    printf("\r\n");
}
~~~

calcu.c文件内容如下：

~~~bash
#include "calcu.h"

int calcu(inta,intb)
{
    return(a +b);
}
~~~

文件input.h内容如下：

~~~bash
#ifndef _INPUT_H
#define _INPUT_H

void input_int(int*a,int*b);

#endif
~~~

文件calcu.h内容如下：

~~~bash
#ifndef _CALCU_H
#define _CALCU_H

intcalcu(inta,intb);

#endif
~~~

以上就是这个小工程的所有源文件，接下来使用前边讲的方法来对其进行编译，在终端输入如下命令：

~~~bash
gcc main.c calcu.c input.c -o main
~~~

上面命令的意思就是使用gcc编译器对main.c、calcu.c和input.c这三个文件进行编译，编译生成的可执行文件叫做main。编译完成以后执行main这个程序。

如果有一个文件被修改了以，使用上面的命令编译的时候所有的文件都会重新编译。最好的办法是哪个文件被修改了，只编译被修改的文件即可，其它没有修改的文件就不再次重新编译了，为此改变编译方法，如果第一次编译工程，先将工程中的文件都编译一遍，然后后面修改了哪个文件就编译哪个文件，命令如下：

~~~bash
gcc -c main.c
gcc -c input.c
gcc -c calcu.c
gcc main.o input.o calcu.o -o main
~~~

上述命令前三行分别是将main.c、input.c和calcu.c编译成对应的.o文件，所以使用了“-c”选项，“-c”选项我们上面说了，是只编译不链接。最后一行命令是将编译出来的所有.o文件链接成可执行文件main。假如我们现在修改了calcu.c这个文件，只需要将caclue.c这一个文件重新编译成.o文件，然后在将所有的.o文件链接成可执行文件即，只需要下面两条命令即可：

~~~bash
gcc -c calcu.c
gcc main.o input.o calcu.o -o main
~~~

如果修改的文件多，可能都不记得哪个文件修改过了，为此我们需要这样一个工具：

1、如果工程没有编译过，那么工程中的所有.c文件都要被编译并且链接成可执行程序。

2、如果工程中只有个别C文件被修改了，那么只编译这些被修改的C文件即可。

3、如果工程的头文件被修改了，那么我们需要编译所有引用这个头文件的C文件，并且链接成可执行文件。

很明显，能够完成这个功能的就是Makefile了，在工程目录下创建名为“Makefile”的文件，文件名一定要叫做“Makefile”
！区分大小写！

Makefile和C文件是处于同一个目录的，在Makefile文件中输入如下代码：

~~~Makefile
main:main.o input.o calcu.o
    gcc -o main  main.o input.o calcu.o
main.o:main.c
    gcc -c main.c
input.o:input.c
    gcc -c input.c
calcu.o:calcu.c
    gcc -c calcu.c
    
clean:
    rm *.o
    rm main
~~~

上述代码中所有行首需要空出来的地方一定要使用“TAB”键！不要使用空格键！这是Makefile的语法要求。

Makefile编写好以后就可以使用make命令来编译工程了，直接在命令行中输入“make”即可，make命令会在当前目录下查找是否存在“Makefile”这个文件，如果存在的话就会按照Makefile里面定义的编译方式进行编译

使用命令“make”编译完成以后就会在当前工程目录下生成各种.o和可执行文件，说明编译成功了。

使用make命令编译工程的时候可能会提示如下错误：

~~~Makefile
Makefile:2:*** missing separator。停止。
~~~

错误来源一般有两点:

1、Makefile中命令缩进没有使用TAB键！

2、VI/VIM编辑器使用空格代替了TAB键，修改文件/etc/vim/vimrc，在文件最后面加上如下所示代码：

~~~bash
set noexpandtab
~~~

修改一下文件源码，随便加几行空行，保证文件被修改过即可，修改完成以后再执行一下“make”命令重新编译一下工程。

因为修改了input.c这个文件，所以input.c和最后的可执行文件main重新编译了，其它没有修改过的文件就没有编译。而且只需要输入“make”这个命令即可，非常方便。

### 8.3 Makefile语法

#### 8.3.1 Makefile规则格式

Makefile里面是由一系列的规则组成的，这些规则格式如下：

~~~bash
目标...... :   依赖文件集合......
    命令1
    命令2
    ......
~~~

比如下面这条规则：

~~~bash
main:main.o input.o calcu.o
    gcc -o main main.o input.o calcu.o
~~~

这条规则的目标是main，main.o、input.o和calcu.o是生成main的依赖文件，如果要更新目标main，就必须先更新它的所有依赖文件，如果依赖文件中的任何一个有更新，那么目标也必须更新，“更新”就是执行一遍规则中的命令列表。

命令列表中的每条命令必须以TAB键开始，不能使用空格！

make命令会为Makefile中的每个以TAB开始的命令创建一个Shell进程去执行。

了解了Makefile的基本运行规则以后，来分析一下如下代码：

~~~Makefile
main:main.o input.o calcu.o
    gcc -o main  main.o input.o calcu.o
main.o:main.c
    gcc -c main.c
input.o:input.c
    gcc -c input.c
calcu.o:calcu.c
    gcc -c calcu.c
    
clean:
    rm *.o
    rm main
~~~

上述代码中一共有5条规则，1~2行为第一条规则，3~4行为第二条规则，5~6行为第三条规则，7~8行为第四条规则，10~12为第五条规则，make命令在执行这个Makefile的时候其执行步骤如下：

首先更新第一条规则中的main，第一条规则的目标成为默认目标，只要默认目标更新了就认为Makefile的工作完成了，整个Makefile就是为了完成这个工作。在第一次编译的时候由于main还不存在，因此第一条规则会执行，第一条规则依赖于文件main.o、input.o和calcu.o这个三个.o文件，这三个.o文件目前还都没有，因此必须先更新这三个文件。make会查找以这三个.o文件为目标的规则并执行。以main.o为例，发现更新main.o的是第二条规则，因此会执行第二条规则，第二条规则里面的命令为“gcc –c main.c”，这行命令是不链接编译main.c，生成main.o，其它两个.o文件同理。最后一个规则目标是clean，它没有依赖文件，因此会默认为依赖文件都是最新的，所以其对应的命令不会执行，当想要执行clean的时候可以直接使用命令“make clean”，执行以后就会删除当前目录下所有的.o文件以及main，因此clean的功能就是完成工程的清理。

当执行“make clean”命令以后，前面编译出来的.o和main可执行文件都被删除掉了，也就完成了工程清理工作。

再来总结一下Make的执行过程：

1、make命令会在当前目录下查找以Makefile(makefile其实也可以)命名的文件。

2、当找到Makefile文件以后就会按照Makefile中定义的规则去编译生成最终的目标文件。

3、当发现目标文件不存在，或者目标所依赖的文件比目标文件新(也就是最后修改时间比目标文件晚)的话就会执行后面的命令来更新目标。

这就是make的执行过程，make工具就是在Makefile中一层一层的查找依赖关系，并执行相应的命令。编译出最终的可执行文件。Makefile的好处就是“自动化编译”，一旦写好了Makefile文件，以后只需要一个make命令即可完成整个工程的编译，极大的提高了开发效率。

总结一下，Makefile中规则用来描述在什么情况下使用什么命令来构建一个特定的文件，这个文件就是规则的“目标”，为了生成这个“目标”而作为材料的其它文件称为“目标”的依赖，规则的命令是用来创建或者更新目标的。除了Makefile的“终极目标”所在的规则以外，其它规则的顺序在Makefile中是没有意义的，“终极目标”就是指在使用make命令的时候没有指定具体的目标时，make默认的那个目标，它是Makefile文件中第一个规则的目标，如果Makefile中的第一个规则有多个目标，那么这些目标中的第一个目标就是make的“终极目标”。

#### 8.3.2 Makefile变量

跟C语言一样Makefile也支持变量的，先看一下前面的例子：

~~~Makefile
main:main.o input.o calcu.o
    gcc -o main  main.o input.o calcu.o
~~~

上述Makefile语句中，main.o input.o和calcue.o这三个依赖文件，输入了两遍，这个Makefile比较小，如果Makefile复杂的时候这种重复输入的工作就会非常费时间，而且非常容易输错，为了解决这个问题，Makefile加入了变量支持。不像C语言中的变量有int、char等各种类型，Makefile中的变量都是字符串！类似C语言中的宏。使用变量将上面的代码修改，修改以后如下所示：

~~~Makefile
#Makefile变量的使用
objects =main.o input.o calcu.o
main:$(objects)
    gcc -o main $(objects)
~~~

第1行是注释，Makefile中可以写注释，注释开头要用符号“#”，不能用C语言中的“//”或者“/**/”！第2行定义了一个变量objects，并且给这个变量进行了赋值，其值为字符串“main.o input.o calcu.o”，第3和4行使用到了变量objects，Makefile中变量的引用方法是“$(变量名)”，比如本例中的“$(objects)”就是使用变量objects。

在定义变量objects的时候使用“=”对其进行了赋值，Makefile变量的赋值符还有其它两个“:=”和“?=”，这三种赋值符的区别：

#### 8.3.2.1 赋值符“=”

使用“=”在给变量的赋值的时候，不一定要用已经定义好的值，也可以使用后面定义的值，比如如下代码：

~~~Makefile
name=zzk
curname=$(name)
name=zuozhongkai

print:
    @echo curname:$(curname)
~~~

第1行定义了一个变量name，变量值为“zzk”，第2行也定义了一个变量curname，curname的变量值引用了变量name，按照我们C写语言的经验此时curname的值就是“zzk”。第3行将变量name的值改为了“zuozhongkai”，第5、6行是输出变量curname的值。在Makefile要输出一串字符的话使用“echo”，就和C语言中的“printf”一样，第6行中的“echo”前面加了个“@”符号，因为Make在执行的过程中会自动输出命令执行过程，在命令前面加上“@”的话就不会输出命令执行过程，大家可以测试一下不加“@”的效果。

使用命令“makeprint”来执行上述代码，结果curname的值不是“zzk”，是“zuozhongkai”，也就是变量“name”最后一次赋值的结果。

#### 8.3.2.2 赋值符“:=”

修改上述代码中的第2行，将其中的“=”改为“:=”，修改完成以后的代码如下：

~~~Makefile
name=zzk
curname:=$(name)
name=zuozhongkai

print:
    @echo curname:$(curname)
~~~

修改完成以后重新执行一下Makefile，此时的curname是zzk，不是zuozhongkai了。这是因为赋值符“:=”不会使用后面定义的变量，只能使用前面已经定义好的，这就是“=”和“:=”两个的区别。

#### 8.3.2.3 赋值符“?=”

“?=”是一个很有用的赋值符，比如下面这行代码：

~~~Makefile
curname?=zuozhongkai
~~~

上述代码的意思就是，如果变量curname前面没有被赋值，那么此变量就是“zuozhongkai”，如果前面已经赋过值了，那么就使用前面赋的值。

#### 8.3.2.4 变量追加“+=”

Makefile中的变量是字符串，有时候我们需要给前面已经定义好的变量添加一些字符串进去，此时就要使用到符号“+=”，比如如下所示代码：

~~~Makefile
objects=main.o inpiut.o
objects+=calcu.o
~~~

开始变量objects的值为“main.o input.o”，后面追加了一个“calcu.o”，因此变量objects变成了“main.o input.o calcu.o”，这个就是变量的追加。

### 8.4 Makefile自动化变量

所谓自动化变量就是这种变量会把模式中所定义的一系列的文件自动取出，直至所有的符合模式的文件都取完，自动化变量只应该出现在规则的命令中，常用的自动化变量如表：

|自动化变量|描述|
|:----:|:----:|
|$@|规则中的目标集合，在模式规则中，如果有多个目标的话，“$@”表示匹配模式中定义的目标集合。|
|$%|当目标是函数库的时候表示规则中的目标成员名，如果目标不是函数库文件，那么其值为空。|
|$<|依赖文件集合中的第一个文件，如果依赖文件是以模式(即“%”)定义的，那么“$<”就是符合模式的一系列的文件集合。|
|$?|所有比目标新的依赖目标集合，以空格分开。|
|$^|所有依赖文件的集合，使用空格分开，如果在依赖文件中有多个重复的文件，“$^”会去除重复的依赖文件，值保留一份。|
|$+|和“$^”类似，但是当依赖文件存在重复的话不会去除重复的依赖文件。|
|$*|这个变量表示目标模式中"%"及其之前的部分，如果目标是test/a.test.c，目标模式为a.%.c，那么“$*”就是test/a.test。|

7个自动化变量中，常用的三种：$@、$<和$^，使用自动化变量来完成上述Makefile，最终的完整代码如下所示：

~~~Makefile
objects=main.o input.o calcu.o
main:$(objects)
    gcc -o main $(objects)

%.o :%.c
    gcc -c $<

clean:
    rm *.o
    rm main
~~~

### 8.5 Makefile伪目标

Makefile有一种特殊的目标——伪目标，一般的目标名都是要生成的文件，而伪目标不代表真正的目标名，在执行make命令的时候通过指定这个伪目标来执行其所在规则的定义的命令。

使用伪目标的主要是为了避免Makefile中定义的只执行命令的目标和工作目录下的实际文件出现名字冲突，有时候需要编写一个规则用来执行一些命令，但是这个规则不是用来创建文件的，比如在前面的Makefile文件中有如下代码用来完成清理工程的功能：

~~~Makefile
clean:
    rm *.o
    rm main
~~~

上述规则中并没有创建文件clean的命令，因此工作目录下永远都不会存在文件clean，当输入“make clean”以后，后面的“rm*.o”和“rmmain”总是会执行。可是，如果在工作目录下创建一个名为“clean”的文件，那就不一样了，当执行“make clean”的时候，规则因为没有依赖文件，所以目标被认为是最新的，因此后面的rm命令也就不会执行，预先设想的清理工程的功能也就无法完成。为了避免这个问题，可以将clean声明为伪目标，声明方式如下：

~~~Makefile
.PHONY:clean
~~~

我们使用伪目标来更改上述Makefile文件，修改完成以后如下：

~~~Makefile
objects=main.o input.o calcu.o
main:$(objects)
    gcc -o main $(objects)

.PHONY:clean

%.o :%.c
    gcc -c $<

clean:
    rm *.o
    rm main
~~~

上述代码第5行声明clean为伪目标，声明clean为伪目标以后不管当前目录下是否存在名为“clean”的文件，输入“makeclean”的话规则后面的rm命令都会执行。

### 8.6 Makefile条件判断

在C语言中可以通过条件判断语句来根据不同的情况来执行不同的分支，Makefile也支持条件判断，语法有两种如下：

~~~bash
<条件关键字>
    <条件为真时执行的语句>
endif
~~~

以及：

~~~bash
<条件关键字>
    <条件为真时执行的语句>
else
    <条件为假时执行的语句>
endif
~~~

其中条件关键字有4个：ifeq、ifneq、ifdef和ifndef，这四个关键字其实分为两对：ifeq与ifneq、ifdef与ifndef。

先来看一下ifeq和ifneq，ifeq用来判断是否相等，ifneq就是判断是否不相等，ifeq用法如下：

~~~bash
ifeq(<参数1>,<参数2>)
ifeq ‘<参数1>’,‘<参数2>’
ifeq “<参数1>”, “<参数2>”
ifeq“<参数1>”,‘<参数2>’
ifeq‘<参数1>’,“<参数2>”
~~~

上述用法中都是用来比较“参数1”和“参数2”是否相同，如果相同则为真，“参数1”和“参数2”可以为函数返回值。ifneq的用法类似，只不过ifneq是用来了比较“参数1”和“参数2”是否不相等，如果不相等的话就为真。

ifdef和ifndef的用法如下：

~~~bash
ifdef <变量名>
~~~

如果“变量名”的值非空，那么表示表达式为真，否则表达式为假。“变量名”同样可以是一个函数的返回值。ifndef用法类似，但是含义用户ifdef相反。

### 8.7 Makefile函数使用

Makefile支持函数，类似C语言一样，Makefile中的函数是已经定义好的，可以直接使用，不支持自定义函数。make所支持的函数不多，但是绝对够用，函数的用法如下：

~~~bash
    $(函数名参数集合)
或者
    ${函数名参数集合}
~~~

可以看出，调用函数和调用普通变量一样，使用符号“$”来标识。参数集合是函数的多个参数，参数之间以逗号“,”隔开，函数名和参数之间以“空格”分隔开，函数的调用以“$”开头。接下来介绍几个常用的函数，其它的函数大家可以参考《跟我一起写Makefile》这份文档。

### 8.7.1 函数subst

函数subst用来完成字符串替换，调用形式如下：

~~~bash
$(subst<from>,<to>,<text>)
~~~

此函数的功能是将字符串"text"中的"from"内容替换为"to"，函数返回被替换以后的字符串，比如如下示例：

~~~bash
$(subst zzk,ZZK,my name is zzk)
~~~

把字符串“my name is zzk”中的“zzk”替换为“ZZK”，替换完成以后的字符串为“my name is ZZK”。

### 8.7.2 函数patsubst

函数patsubst用来完成模式字符串替换，使用方法如下：

~~~bash
$(patsubst <pattern>,<replacement>,<text>)
~~~

此函数查找字符串"text"中的单词是否符合模式"pattern"，如果匹配就用"replacement"来替换掉，"pattern"可以使用包括通配符“%”，表示任意长度的字符串，函数返回值就是替换后的字符串。如果"replacement"中也包涵“%”，那么"replacement"中的“%”将是"pattern"中的那个“%”所代表的字符串，比如：

~~~bash
$(patsubst %.c,%.o,a.c b.c c.c)
~~~

将字符串“a.c b.c c.c”中的所有符合“%.c”的字符串，替换为“%.o”，替换完成以后的字符串为“a.o b.o c.o”。

### 8.7.3 函数dir

函数dir用来获取目录，使用方法如下：

~~~bash
$(dir<names...>)
~~~

此函数用来从文件名序列"names"中提取出目录部分，返回值是文件名序列"names"的目录部分，比如：

~~~bash
$(dir </src/a.c>)
~~~

提取文件“/src/a.c”的目录部分，也就是“/src”。

### 8.7.4 函数notdir

函数notdir是去除文件中的目录部分，也就是提取文件名，用法如下：

~~~bash
$(notdir <names...>)
~~~

此函数用与从文件名序列"names"中提取出文件名非目录部分，比如：

~~~bash
$(notdir </src/a.c>)
~~~

提取文件“/src/a.c”中的非目录部分，也就是文件名“a.c”。

### 8.7.5 函数foreach

foreach函数用来完成循环，用法如下：

~~~bash
$(foreach <var>, <list>,<text>)
~~~

此函数的意思就是把参数"list"中的单词逐一取出来放到参数"var"中，然后再执行"text"所包含的表达式。每次"text"都会返回一个字符串，循环的过程中，"text"中所包含的每个字符串会以空格隔开，最后当整个循环结束时，"text"所返回的每个字符串所组成的整个字符串将会是函数foreach函数的返回值。

### 8.7.6 函数wildcard

通配符“%”只能用在规则中，只有在规则中它才会展开，如果在变量定义和函数使用时，通配符不会自动展开，这个时候就要用到函数wildcard，使用方法如下：

~~~bash
$(wildcard PATTERN...)
~~~

比如：

~~~bash
$(wildcard *.c)
~~~

上面的代码是用来获取当前目录下所有的.c文件，类似“%”。关于Makefile的相关内容就讲解到这里，本节只是对Makefile做了最基本的讲解，确保大家能够完成后续的学习，Makefile还有大量的知识没有提到，有兴趣的可以自行参考《跟我一起写Makefile》这份文档来深入学习Makefile。
